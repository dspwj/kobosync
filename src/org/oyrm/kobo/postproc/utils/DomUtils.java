/* 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package org.oyrm.kobo.postproc.utils;

import java.io.File;
import java.io.IOException;
import java.util.Arrays;
import java.util.logging.FileHandler;
import java.util.logging.Formatter;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.oyrm.kobo.postproc.constants.Constants;
import org.oyrm.kobo.postproc.data.SurveyRecord;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;

/**
 * DomUtils provides the means to read in survey xml files and generate
 * SurveyRecords
 * 
 * @author Gary Hendrick
 * 
 */
public final class DomUtils {
	private static Logger logger = Logger.getLogger("org.oyrm.kobo");
	private static FileHandler lh;
	private static Formatter lf;
	static {
		try {
			lh = new FileHandler(System.getProperty("user.home")
					+ File.separator + Constants.CONFIG_STORAGEDIR
					+ File.separator + "kobo.log", true);
			lf = new SimpleFormatter();
		} catch (SecurityException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		lh.setFormatter(lf);
		logger.addHandler(lh);
		try {
			logger.setLevel(Level.parse(System.getProperty(Constants.PROPKEY_LOGGING_LEVEL)));
		} catch(IllegalArgumentException ex) {
			logger.setLevel(Level.OFF);
			System.out.println("Logging function failed due to exception");
			System.out.println(ex.getMessage());
		}
	}

	public static Document createDocument(File docFile) throws Exception {
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		Document doc;
		try {
			DocumentBuilder builder = factory.newDocumentBuilder();
			doc = builder.parse(docFile);
		} catch (SAXParseException spe) {
			// Error generated by the parser
			logger.warning("Parsing error" + ", line " + spe.getLineNumber()
					+ ", uri " + spe.getSystemId());
			logger.warning(spe.getMessage());

			// Use the contained exception, if any
			Exception x = spe;
			if (spe.getException() != null)
				x = spe.getException();
			logger.warning(Arrays.asList(x.getStackTrace()).toString());
			throw spe;
		} catch (SAXException sxe) {
			// Error generated during parsing
			Exception x = sxe;
			if (sxe.getException() != null)
				x = sxe.getException();
			logger.warning(Arrays.asList(x.getStackTrace()).toString());
			throw sxe;
		} catch (ParserConfigurationException pce) {
			// Parser with specified options can't be built
			logger.warning(Arrays.asList(pce.getStackTrace()).toString());
			throw pce;
		} catch (IOException ioe) {
			// I/O error
			logger.warning(Arrays.asList(ioe.getStackTrace()).toString());
			throw ioe;
		}
		return doc;
	}

	public static Node findSubNode(String name, Node node) {
		if (node.getNodeType() != Node.ELEMENT_NODE) {
			return null;
		}
		if (!node.hasChildNodes())
			return null;

		NodeList list = node.getChildNodes();
		for (int i = 0; i < list.getLength(); i++) {
			Node subnode = list.item(i);
			if (subnode.getNodeType() == Node.ELEMENT_NODE) {
				if (subnode.getNodeName().equals(name))
					return subnode;
			}
		}
		return null;
	}

	public static SurveyRecord documentToSurveyRecord(Document doc) {
		logger.entering(DomUtils.class.getCanonicalName(),
				"documentToSurveyRecord");
		Node node = doc.getDocumentElement();
		if (node == null) {
			logger.info("Document has no document element");
			return null;
		}
		if (node.getNodeType() != Node.ELEMENT_NODE) {
			logger.info("Document document element is not a Node.ELEMENT_NODE");
			return null;
		}
		if (!node.hasChildNodes()) {
			logger.info("document element has no children");
			return null;
		}


		node.normalize();
		SurveyRecord record = new SurveyRecord();

		record.setInstance(node.getNodeName());
		NodeList list = node.getChildNodes();

		for (int i = 0; i < list.getLength(); i++) {
			Node subnode = list.item(i);
			visit(record, subnode, 1);
		}
		return record;
	}

	/*
	** visit recursively visits every node beneath the first given
	** this instance of visit will manage transcribing the node with
    ** consideration given to naming conventions required for KoBo
	*/
	public static void visit(SurveyRecord record, Node node, int level) {
		// Examine Node for relevant content
		if (node.getNodeType() == Node.ELEMENT_NODE) {
			node.normalize();
			if (node.hasChildNodes() && node.getFirstChild().getNextSibling()!= null) {
				NodeList list = node.getChildNodes();
				for (int i = 0; i < list.getLength(); i++) {
					// Get child node
					Node childNode = list.item(i);

					// Visit child node
					visit(record, childNode, level + 1);
				}
			} else {
				String fieldname = growFieldName(node, level);
				// Determine if the node is a multi select node
				// Condition 1 : endsWith(Constants.MULTI_TAG)
				if (node.getNodeName().endsWith(Constants.MULTI_TAG)) {
					// Process the answer, if it is a Multi Select
					// Condition 2 : answers must not themselves contain any
					// spaces
					for (String selection : node.getTextContent().split(" ")) {
						if (selection.isEmpty())
							break;
						record.setAnswer(fieldname + selection, "1");
					}
				} else {
					record.setAnswer(fieldname, node.getTextContent());
				}
			}
		}
	}

	private static String growFieldName(Node node, int level) {
		StringBuilder fieldname = new StringBuilder();
		int idx = 0;
		for (int i = level; i > 0; i--) {
			if(node.getPreviousSibling() != null
					|| node.getNextSibling() != null) {
				// possible to have this be a repeated name
				idx = findRepeatitionPos(node);
			}
			// Ternary operation, if this is a repetition, then add an index
			fieldname.insert(0, idx > 0 ? node.getNodeName().concat(Integer.toString(idx)) : node.getNodeName());
			if(i > 1) {
				fieldname.insert(0, Constants.STRING_DELIM_GROUPFROMCHILD);
			}
			node = node.getParentNode();
			idx = 0;
		}
		return fieldname.toString();
	}

	/*
	 * findRepeatitionPos
	 * @returns position of the name, index begin at 0
	 */
	private static int findRepeatitionPos(Node node) {
		int idx = 0;
		Node oNode = null;
		oNode = node.getPreviousSibling();
		while (oNode != null) {
			if(oNode.getNodeName().equals(node.getNodeName()))
				idx++;
			oNode = oNode.getPreviousSibling();
		}
		return idx;
	}
}
